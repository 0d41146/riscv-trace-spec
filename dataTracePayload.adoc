[[dataTracePackets]]
== Data Trace Encoder Output Packets

Data trace packets must be differentiated from instruction trace
packets, and the means by which this is accomplished is dependent on the
trace transport infrastructure. Several possibilities exist: One option
is for instruction and data trace to be issued using different IDs (for
example, if using ATB transport, different *ATID* values).
Alternatively, an additional field as part of the packet encapsulation
can be used (Siemens uses a 2-bit *msg_type* field to differentiate
different trace types from the same source).

By default, all data trace packets include both address and data.
However, provision is made for run-time configuration options to exclude
either the address or the data, in order to minimize trace bandwidth.
For example, if filtering has been configured to only trace from a
specific data access address there is no need to report the address in
the trace. Alternatively, the user may want to know which locations are
accessed but not care about the data value. Information about whether
address or data are omitted is not encoded in the packets themselves as
it does not change dynamically, and to do so would reduce encoding
efficiency. The run-time configuration should be reported in the Format
3, subformat 3 support packet (see
section #sec:format33[[sec:format33]]). The following sections include
examples for all three cases.

As outlined in
section #sec:DataInterfaceRequirements[[sec:DataInterfaceRequirements]],
two different signaling protocols between the RISC-V hart and the
encoder are supported: _unified_ and _split_. Accordingly, both unified
and split trace packets are defined.

Note: in the following tables, "clog2" is an abbreviation for "ceiling
of log2".

[[sec:data-loadstore]]
=== Load and Store

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 2 or 3 & Transaction type: Unified load or split load
address, aligned: Unified load or split load address, unaligned: Store,
aligned address: Store, unaligned address (other codes select other
packet formats) +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 2 & 00: Full address and data (sync): Differential address,
XOR-compressed data: Differential address, full data: Differentail
address, differential data +
*data_len* & *size* & Number of bytes of data is *data_len* + 1 +
*data* & 8 * (*data_len* + 1) & Data +
*address* & _daddress_width_p_ & Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 2 or 3 & Transaction type: Unified load or split load
address, aligned: Unified load or split load address, unaligned: Store,
aligned address: Store, unaligned address (other codes select other
packet formats) +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 1 & 0: Full address (sync) : Differential address +
*address* & _daddress_width_p_ & Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 2 or 3 & Transaction type: Unified load or split load
address, aligned: Unified load or split load address, unaligned: Store,
aligned address: Store, unaligned address (other codes select other
packet formats) +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 1 or 2 & 00: Full data (sync): Compressed data (XOR if 2 bits)
: reserved : Differential data +
*data* & _data_width_p_ & Data +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Unified load or split load address,
aligned: Unified load or split load address, unaligned (other codes
select other packet formats) +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*lrid* & _lrid_width_p_ & Load request ID +
*diff* & 1 & 0: Full address (sync) : Differential address +
*address* & _daddress_width_p_ & Byte address if format is unaligned,
otherwise shift left by *size* to recover byte address +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: split load data (other codes select
other packet formats) +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*lrid* & _lrid_width_p_ & Load request ID +
*resp* & 2 & 00: Error (no data): XOR-compressed data: Full data:
Differential data +
*data* & _data_width_p_ & Data +

[[sec:loadstore-format]]
==== format field

Types of data trace packets are differentiated by the *format* field.
This field is 2 bits wide if only unified loads and stores are
supported, or 3 bits otherwise.

Unified loads and split load request phase share the same code because
the encoder will support one or the other, indicated by a discoverable
parameter.

Data accesses aligned to their size (e.g. 32-bit loads aligned to 32-bit
word boundaries) are expected to be commonplace, and in such cases,
encoding efficiency can be improved by not reporting the redundant LSBs
of the address.

[[sec:loadstore-size]]
==== size field

The width of this field is 2 bits if max size is 64-bits (_data_width_p_
< 128), 3 bits if wider.

[[sec:loadstore-diff]]
==== diff field

Unlike instruction trace, compression options for data trace are
somewhat limited. Following a synchronization instruction trace packet,
the first data trace packet for a given access size must include the
full (unencoded) data access address. Thereafter, the address may be
reported differentially (i.e. address of this data access, minus the
address of the previous data access of the same size).

Similarly, following a synchronization instruction trace packet, the
first data trace packet for a given access size must include the full
(unencoded) data value. Beyond this, data may be encoded or unencoded
depending on whichever results in the most efficient represenation.
Implementors may chose to offer one of XOR or differential compression,
or both. XOR compression will be simpler to implement, and avoids the
need for performing subtraction of large values.

If only one data compression type is offered, the *diff* field can be 1
bit wide rather than 2 for table #tab:te_datadx0y2[[tab:te_datadx0y2]].

[[sec:loadstore-datalen]]
==== data_len field

However the data is compressed, upper bytes that are all the same value
do not need to be included in the packet; the decoder can recreate the
full-width value by sign extending from the most significant received
bit. In cases where *data* is not the final field in the packet, the
width of *data* is indicated by this field.

[[sec:data-atomic]]
=== Atomic

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Unified atomic or split atomic address
(other codes other packet formats) +
*subtype* & 3 & Atomic sub-type: Swap: ADD: AND: OR: XOR: MAX: MIN:
reserved +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 2 & 00: Full address and data (sync): Differential address,
XOR-compressed data: Differential address, full data: Differential
address, differential data +
*op_len* & *size* & Number of bytes of operand is *op_len* + 1 +
*operand* & 8 * (*op_len* + 1) & Operand. Value from rs2 before operator
applied +
*data_len* & *size* & Number of bytes of data is *data_len* + 1 +
*data* & 8 * (*data_len* + 1) & Data +
*address* & _daddress_width_p_ & Address, aligned and encoded as per
size +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Unified atomic or split atomic address
(other codes other packet formats) +
*subtype* & 3 & Atomic sub-type: Swap: ADD: AND: OR: XOR: MAX: MIN:
conditional store failure +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 1 & 0: Full address : Differential address +
*address* & _daddress_width_p_ & Address, aligned and encoded as per
size +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Unified atomic or split atomic address
(other codes other packet formats) +
*subtype* & 3 & Atomic sub-type: Swap: ADD: AND: OR: XOR: MAX: MIN:
reserved +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes +
*diff* & 1 or 2 & 00: Full data (sync): Compressed data (XOR if 2 bits)
: reserved : Differential data +
*op_len* & *size* & Number of bytes of operand is *op_len* + 1 +
*operand* & 8 * (*op_len* + 1) & Operand. Value from rs2 before operator
applied +
*data* & _data_width_p_ & Data +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Unified atomic or split atomic address
(other codes other packet formats) +
*subtype* & 3 & Atomic sub-type: Swap: ADD: AND: OR: XOR: MAX: MIN:
reserved +
*size* & max(1, clog2(clog2( _data_width_p_/8 + 1)) & Transfer size is
2^*size*^ bytes bytes +
*lrid* & _lrid_width_p_ & Load request ID +
*diff* & 1 or 2 & 00: Full address and data (sync): Differential
address, XOR-compressed data: Differential address, full data:
Differential address, differential data +
*op_len* & *size* & Number of bytes of operand is *op_len* + 1 +
*operand* & 8 * (*op_len* + 1) & Operand. Value from rs2 before operator
applied +
*address* & _daddress_width_p_ &Address, aligned and encoded as per
size +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: Split atomic data other codes other
packet formats +
*lrid* & _lrid_width_p_ & Load request ID +
*resp* & 2 & 00: Error (no data): XOR-compressed data: full data:
differential data +
*data_len* & *size* & Number of bytes of operand is _data_len + 1_. Not
included if resp indicates an error (sign-extend *resp* MSB) +
*data* & 8 * (*data_len* + 1) & Data. Not included if resp indicates an
error (sign-extend *resp* MSB) +

[[sec:atomic-size]]
==== size field

Strictly, *size* could be just one bit as atomics are currently either
32 or 64 bits. Defining as per regular loads and stores provisions for
future extensions (proprietary or otherwise) that support smaller
atomics.

[[sec:atomic-diff]]
==== diff field

See section #sec:loadstore-diff[1.1.3].

[[sec:atomic-operand]]
==== operand field

The operand value for the atomic operation. Uncompressed, although upper
bytes that are all the same value do not need to be included in the
packet; the decoder can recreate the full-width value by sign extending
from the most significant received bit; see section
#sec:atomic-datalen[1.2.4].

[[sec:atomic-datalen]]
==== data_len and op_len fields

Width of *data and *operand* fields respectively. See section
#sec:loadstore-datalen[1.1.4].*

[[sec:data-csr]]
=== CSR

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: CSR (other codes other packet
formats) +
*subtype* & 2 & CSR sub-type: RW: RS: RC: reserved +
*diff* & 1 or 2 & 00: Full data (sync): Compressed data (XOR if 2 bits)
: reserved : Differential data +
*data_len* & 2 or 3 & Number of bytes of data is *data_len* + 1 +
*data* & 8 * (*data_len* + 1) & Data +
*addr_msbs* & 6 & Address[11:6] +
*op_len* & 2 or 3 & Number of bytes of operand is *op_len* + 1 +
*operand* & 8 * (*op_len* + 1) & Operand. Value from rs1 before operator
applied +
*addr_lsbs* & 6 & Address[5:0] +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: CSR other codes other packet formats +
*subtype* & 2 & CSR sub-type: RW: RS: RC: reserved +
*diff* & 1 or 2 & 00: Full data (sync): Compressed data (XOR if 2 bits)
: reserved : Differential data +
*data_len* & 2 or 3 & Number of bytes of data is *data_len* + 1 +
*data* & 8 * (*data_len* + 1) & Data +
*addr_msbs* & 6 & Address[11:6] +
*addr_lsbs* & 6 & Address[5:0] +

|l|p38mm|p92mm| *Field name* & *Bits* & *Description* +
*format* & 3 & Transaction type: CSR other codes other packet formats +
*subtype* & 3 & CSR sub-type: RW: RS: RC: reserved +
*diff* & 0 or 1 & 0: Full address: Differential address +
*addr_msbs* & 6 & Address[11:6] +
*addr_lsbs* & 6 & Address[5:0] +

[[sec:csr-diff]]
==== diff field

See section #sec:loadstore-diff[1.1.3].

[[sec:csr-operand]]
==== operand field

See section #sec:atomic-operand[1.2.3].

[[sec:csr-datalen]]
==== data_len and op_len fields

2 bits wide if hart has 32-bit CSRs, 3 bits if 64-bit. Width of *data*
and *operand* fields respectively. See section
#sec:loadstore-datalen[1.1.4].

[[sec:csr-addr]]
==== addr fields

The address is split into two parts, with the 6 LSBs output last as
these are more likely to compress away.
